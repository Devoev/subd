use crate::bspline::basis::{BsplineBasis, ScalarBasis};
use crate::index::dimensioned::{DimShape, Strides};
use crate::index::multi_index::MultiIndex;
use itertools::Itertools;
use nalgebra::{Const, DVector, DimNameAdd, DimNameSum, Dyn, Matrix, OMatrix, RealField, U1};
use std::iter::zip;
use std::marker::PhantomData;

/// A [`BsplineBasis`] generated by tensor products of (univariate) bases.
/// Given a family `{B[i]}ᵢ` of [`D`] bases with `B[i] = {b₁,...,bₙ}`,
/// the tensor product basis functions are defined as
/// ```text
/// bᵢ: X×...×X ⟶ ℝ   x ↦ bᵢ[1](x[1]) ... bᵢ[d](x[d])
/// ```
#[derive(Debug, Clone, Copy)]
pub struct MultiProd<T: RealField, B: ScalarBasis<T, T>, const D: usize> {
    /// The bases for each parametric direction.
    pub bases: [B; D],

    _phantom_data: PhantomData<T>,
}

impl<T: RealField, B: ScalarBasis<T, T>, const D: usize> MultiProd<T, B, D>
    where B::NonzeroIndices: Clone
{
    /// Constructs a new [`MultiProd`] from the given array `bases` of `D` univariate bases.
    pub fn new(bases: [B; D]) -> Self {
        MultiProd { bases, _phantom_data: Default::default() }
    }

    /// Returns the number of basis functions per parametric direction as a [`DimShape`].
    pub fn num_basis(&self) -> DimShape<D> {
        let arr = self.bases.iter()
            .map(|base| base.num_basis())
            .collect_array();
        DimShape(arr.unwrap())
    }

    /// Returns the [`Strides`] for the basis functions.
    pub fn strides(&self) -> Strides<D> {
        Strides::from(self.num_basis())
    }

    /// Computes the evaluated tensor product basis using [`Matrix::kronecker`],
    /// given a vector `b` of univariate basis functions for each parametric direction.
    ///
    /// # Arguments
    /// - `b`: Vector of evaluated basis functions for each parametric direction.
    /// - `idx`: Vector of nonzero indices for each parametric direction.
    fn compute_multi_prod(&self, b: Vec<DVector<T>>, idx: Vec<B::NonzeroIndices>) -> (DVector<T>, impl Iterator<Item = usize>) {
        let b = b.into_iter()
            .reduce(|acc, bi| acc.kronecker(&bi))
            .expect("Dimension D must be greater than 0!");

        let strides = self.strides();
        let idx = idx.into_iter()
            .multi_cartesian_product()
            .map(|i| TryInto::<[usize; D]>::try_into(i).unwrap())
            .map(move |i| i.into_lin(&strides));

        (b, idx)
    }

    /// Evaluates the nonzero basis functions at the parametric point `x`.
    fn eval_multi_prod(&self, x: [T; D]) -> (DVector<T>, impl Iterator<Item = usize>) {
        let (b, idx): (Vec<_>, Vec<_>) = zip(&self.bases, x)
            .map(|(space, xi)| space.eval_nonzero(xi))
            .unzip();

        self.compute_multi_prod(b, idx)
    }

    /// Evaluates the derivative of the tensor product basis
    /// with respect to a single parametric direction `du`
    /// at the parametric point `x`.
    pub fn eval_deriv_multi_prod(&self, x: [T; D], du: usize) -> (DVector<T>, impl Iterator<Item = usize>) {
        let (b, idx): (Vec<_>, Vec<_>) = zip(&self.bases, x)
            .enumerate()
            .map(|(i, (space, xi))| {
                if i == du {
                    let (b, idx) = space.eval_derivs_nonzero::<1>(xi);
                    (b.row(1).transpose(), idx)
                } else {
                    space.eval_nonzero(xi)
                }
            })
            .unzip();

        self.compute_multi_prod(b, idx)
    }
}

impl <T: RealField, B: ScalarBasis<T, T>> BsplineBasis<T, T, 1> for MultiProd<T, B, 1>
    where B::NonzeroIndices: Clone
{
    type NonzeroIndices = impl Iterator<Item = usize>;

    fn num_basis(&self) -> usize {
        self.num_basis().len()
    }

    fn eval_nonzero(&self, x: T) -> (DVector<T>, Self::NonzeroIndices) {
        self.eval_multi_prod([x])
    }
}

impl <T: RealField, B: ScalarBasis<T, T>> BsplineBasis<T, (T, T), 1> for MultiProd<T, B, 2>
    where B::NonzeroIndices: Clone
{
    type NonzeroIndices = impl Iterator<Item = usize>;

    fn num_basis(&self) -> usize {
        self.num_basis().len()
    }

    fn eval_nonzero(&self, x: (T, T)) -> (DVector<T>, Self::NonzeroIndices) {
        self.eval_multi_prod([x.0, x.1])
    }
}

impl <T: RealField, B: ScalarBasis<T, T>, const D: usize> BsplineBasis<T, [T; D], 1> for MultiProd<T, B, D>
    where B::NonzeroIndices: Clone
{
    type NonzeroIndices = impl Iterator<Item = usize>;

    fn num_basis(&self) -> usize {
        self.num_basis().len()
    }

    fn eval_nonzero(&self, x: [T; D]) -> (DVector<T>, Self::NonzeroIndices) {
        self.eval_multi_prod(x)
    }
}

/// A [`BsplineBasis`] generated by the tensor product of two univariate bases [`B1`] and [`B2`].
#[derive(Debug, Clone, Copy)]
pub struct Prod<T: RealField, B1: BsplineBasis<T, T, 1>, B2: BsplineBasis<T, T, 1> = B1> {
    /// First basis.
    pub b1: B1,

    /// Second basis.
    pub b2: B2,

    _phantom_data: PhantomData<T>,
}

impl<T: RealField, B1: BsplineBasis<T, T, 1>, B2: BsplineBasis<T, T, 1>> Prod<T, B1, B2> {
    /// Constructs a new [`Prod`] from the bases `b1` and `b2`.
    pub fn new(b1: B1, b2: B2) -> Self {
        Prod { b1, b2, _phantom_data: Default::default() }
    }

    /// Returns the number of basis functions per parametric direction as a [`DimShape`].
    pub fn num_basis(&self) -> DimShape<2> {
        DimShape([self.b1.num_basis(), self.b2.num_basis()])
    }

    /// Returns the [`Strides`] for the basis functions.
    pub fn strides(&self) -> Strides<2> {
        Strides::from(self.num_basis())
    }
}

impl <T: RealField + Copy, B1: BsplineBasis<T, T, 1>, B2: BsplineBasis<T, T, 1>> BsplineBasis<T, [T; 2], 1> for Prod<T, B1, B2>
    where B2::NonzeroIndices: Clone
{

    type NonzeroIndices = impl Iterator<Item = usize>;

    fn num_basis(&self) -> usize {
        self.num_basis().len()
    }

    fn eval_nonzero(&self, x: [T; 2]) -> (DVector<T>, Self::NonzeroIndices) {
        let (b1, idx1) = self.b1.eval_nonzero(x[0]);
        let (b2, idx2) = self.b2.eval_nonzero(x[1]);

        let b = b1.kronecker(&b2); // todo: check order b1*b2 or b2*b1

        let strides = self.strides();
        let idx = idx1.cartesian_product(idx2)
            .map(move |i| i.into_lin(&strides));

        (b, idx)
    }
}