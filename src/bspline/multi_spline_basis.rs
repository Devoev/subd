use crate::bspline::basis::Basis;
use crate::bspline::spline_basis::SplineBasis;
use crate::knots::index::{Linearize, MultiIndex, Strides};
use crate::knots::knot_span::{KnotSpan, MultiKnotSpan};
use itertools::{izip, Itertools};
use nalgebra::{DVector, RealField, SVector};
use std::iter::zip;

/// A [`D`]-variate B-spline space. 
/// The basis functions are generated by tensor products of univariate B-splines.
#[derive(Debug, Clone)]
pub struct MultiSplineBasis<T: RealField, const D: usize>(pub(crate) [SplineBasis<T>; D]);

impl<T: RealField + Copy, const D: usize> MultiSplineBasis<T, D> {

    /// Constructs a new [`MultiSplineBasis`] from the given univariate spaces.
    pub fn new(spaces: [SplineBasis<T>; D]) -> Self {
        MultiSplineBasis(spaces)
    }
    
    /// Constructs an open [`MultiSplineBasis`] with `n[i] + p[i] + 1` for each direction.
    pub fn open_uniform(n: [usize; D], p: [usize; D]) -> Self {
        let arr: [SplineBasis<T>; D] = zip(n, p)
            .map(|(n, p)| SplineBasis::open_uniform(n, p))
            .collect_vec()
            .try_into()
            .unwrap();
        arr.into()
    }
}

impl <T: RealField + Copy, const D: usize> Basis<T, SVector<T, D>, MultiIndex<usize, D>> for MultiSplineBasis<T, D> {
    type LinIndices = impl Iterator<Item=usize>;

    fn num(&self) -> usize {
        self.n().iter().product()
    }

    fn find_span(&self, t: SVector<T, D>) -> Result<KnotSpan<MultiIndex<usize, D>>, ()> {
        MultiKnotSpan::find(self, t)
    }

    fn nonzero(&self, span: &KnotSpan<MultiIndex<usize, D>>) -> Self::LinIndices {
        span.nonzero_indices(self.p()).linearize(self.strides())
    }

    fn eval(&self, t: SVector<T, D>, span: &MultiKnotSpan<D>) -> DVector<T> {
        izip!(&self.0, t.into_iter(), &span.0)
            .map(|(space, ti, i)| space.eval(*ti, &KnotSpan(*i)))
            .reduce(|acc, bi| acc.kronecker(&bi))
            .expect("Dimension D must be greater than 0!")
    }
}

impl<T: RealField + Copy, const D : usize> MultiSplineBasis<T, D> {
    
    /// Return the number of basis functions per parametric direction.
    pub fn n(&self) -> [usize; D] {
        self.0.iter().map(|knot_vec| knot_vec.n).collect_array().unwrap()
    }
    
    /// Return the degrees of basis functions per parametric direction.
    pub fn p(&self) -> [usize; D] {
        self.0.iter().map(|knot_vec| knot_vec.p).collect_array().unwrap()
    }
    
    /// Returns the strides for the multi index ordering of the basis functions.
    pub fn strides(&self) -> Strides<usize, D> {
        Strides::from_dims(self.n())
    }
}

impl<T: RealField + Copy, const D: usize> From<[SplineBasis<T>; D]> for MultiSplineBasis<T, D> {
    fn from(value: [SplineBasis<T>; D]) -> Self {
        MultiSplineBasis::new(value)
    }
}