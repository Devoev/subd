use crate::bspline::spline_basis::SplineBasis;
use crate::bspline::tensor_prod::MultiProd;
use itertools::Itertools;
use nalgebra::{RealField, SVector};
use std::iter::zip;
use crate::knots::knot_span::{KnotSpan, KnotSpan1, MultiKnotSpan};

/// A [`D`]-variate B-spline space.
/// The basis functions are generated by tensor products of univariate B-splines.
// #[derive(Debug, Clone)]
// pub struct MultiSplineBasis<T: RealField, const D: usize>(pub(crate) [SplineBasis<T>; D]);
pub type MultiSplineBasis<T, const D: usize> = MultiProd<T, T, SplineBasis<T>, D>;

impl<T: RealField + Copy, const D: usize> MultiSplineBasis<T, D> {
    /// Constructs an open [`MultiSplineBasis`] with `n[i] + p[i] + 1` for each direction.
    pub fn open_uniform(n: [usize; D], p: [usize; D]) -> Self {
        let arr: [SplineBasis<T>; D] = zip(n, p)
            .map(|(n, p)| SplineBasis::open_uniform(n, p))
            .collect_vec()
            .try_into()
            .unwrap();

        MultiSplineBasis::new(arr)
    }
}

impl<T: RealField + Copy, const D : usize> MultiSplineBasis<T, D> {

    // todo: remove this legacy method
    pub(crate) fn find_span(&self, t: SVector<T, D>) -> Result<MultiKnotSpan<D>, ()> {
        MultiKnotSpan::find(self, t)
    }

    /// Return the degrees of basis functions per parametric direction.
    pub fn degrees(&self) -> [usize; D] {
        self.bases.iter().map(|b| b.p).collect_array().unwrap()
    }
}

impl<T: RealField + Copy, const D: usize> From<[SplineBasis<T>; D]> for MultiSplineBasis<T, D> {
    fn from(value: [SplineBasis<T>; D]) -> Self {
        MultiSplineBasis::new(value)
    }
}