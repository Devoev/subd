use crate::index::dimensioned::{DimShape, Strides};
use crate::index::multi_index::MultiIndex;
use itertools::{izip, Itertools};
use nalgebra::{vector, Const, Dyn, OMatrix, RealField, RowDVector};
use std::iter::zip;
use std::marker::PhantomData;
use crate::basis::global::GlobalBasis;
use crate::basis::traits::Basis;
use crate::cells::hyper_rectangle::HyperRectangle;

/// A multivariate basis generated by tensor products of (univariate) scalar bases.
/// Given a family `{B[i]}ᵢ` of [`D`] bases with `B[i] = {b₁,...,bₙ}`,
/// the tensor product basis functions are defined as
/// ```text
/// bᵢ: X×...×X ⟶ ℝ   x ↦ bᵢ[1](x[1]) ... bᵢ[d](x[d])
/// ```
#[derive(Debug, Clone, Copy)]
pub struct MultiProd<T: RealField, B, const D: usize> {
    /// The bases for each parametric direction.
    pub bases: [B; D],

    _phantom_data: PhantomData<T>,
}

impl<T: RealField, B, const D: usize> MultiProd<T, B, D> {
    /// Constructs a new [`MultiProd`] from the given array `bases` of `D` univariate bases.
    pub fn new(bases: [B; D]) -> Self {
        MultiProd { bases, _phantom_data: Default::default() }
    }
}

// todo: implement shape and strides for GlobalBasis as well, be using super-trait GlobalBasis: Basis

impl<T: RealField, B: GlobalBasis<T, T, 1>, const D: usize> MultiProd<T, B, D> {
    /// Returns the number of **global** basis functions per parametric direction as a [`DimShape`].
    pub fn shape_global(&self) -> DimShape<D> {
        let arr = self.bases.iter()
            .map(|base| base.num_basis())
            .collect_array();
        DimShape(arr.unwrap())
    }

    /// Returns the [`Strides`] for the **global** basis functions.
    pub fn strides_global(&self) -> Strides<D> {
        Strides::from(self.shape_global())
    }
}

impl<T: RealField, B: Basis<T, T, 1>, const D: usize> MultiProd<T, B, D> {
    /// Returns the number of basis functions per parametric direction as a [`DimShape`].
    pub fn shape(&self) -> DimShape<D> {
        let arr = self.bases.iter()
            .map(|base| base.num_basis())
            .collect_array();
        DimShape(arr.unwrap())
    }

    /// Returns the [`Strides`] for the basis functions.
    pub fn strides(&self) -> Strides<D> {
        Strides::from(self.shape())
    }

    /// Evaluates the tensor product basis at `x`
    /// by applying [`Matrix::kronecker`] to each univariate basis.
    fn eval_multi_prod(&self, x: [T; D]) -> RowDVector<T> {
        zip(&self.bases, x)
            .map(|(b, xi)| b.eval(xi))
            .reduce(|acc, bi| acc.kronecker(&bi))
            .expect("Dimension D must be greater than 0!")
    }
}

impl<T: RealField, B: Basis<T, T, 1>, const D: usize> Basis<T, [T; D], 1> for MultiProd<T, B, D> {
    fn num_basis(&self) -> usize {
        self.shape().len()
    }

    fn eval(&self, x: [T; D]) -> OMatrix<T, Const<1>, Dyn> {
        self.eval_multi_prod(x)
    }
}

impl<T: RealField + Copy, B: GlobalBasis<T, T, 1, Elem=HyperRectangle<T, 1>>, const D: usize> GlobalBasis<T, [T; D], 1> for MultiProd<T, B, D>
    where B::GlobalIndices: Clone,
{
    type Elem = HyperRectangle<T, D>;
    type LocalBasis = MultiProd<T, B::LocalBasis, D>;
    type GlobalIndices = impl Iterator<Item = usize> + Clone;

    fn num_basis(&self) -> usize {
        self.bases.iter().map(|base| base.num_basis()).product()
    }

    // todo: update this implementation by making HyperRectangle actually a MultiProd<Interval>
    fn local_basis(&self, elem: &Self::Elem) -> Self::LocalBasis {
        let bases = izip!(&self.bases, &elem.a, &elem.b)
            .map(|(b, &ai, &bi)| {
                let interval = HyperRectangle::new(vector![ai], vector![bi]);
                b.local_basis(&interval)
            }).collect_array().unwrap();
        MultiProd::new(bases)
    }

    fn global_indices(&self, local_basis: &Self::LocalBasis) -> Self::GlobalIndices {
        let strides = self.strides_global();
        zip(&self.bases, &local_basis.bases)
            .map(|(b, b_local)| b.global_indices(b_local))
            .multi_cartesian_product()
            .map(|i| TryInto::<[usize; D]>::try_into(i).unwrap())
            .map(move |i| i.into_lin(&strides))
    }
}