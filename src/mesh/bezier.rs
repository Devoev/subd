use crate::bspline::spline_geo::SplineGeo;
use crate::knots::knot_span::KnotSpan;
use crate::mesh::knot_mesh::{KnotMesh, KnotSpanIter};
use crate::mesh::traits::MeshTopology;
use nalgebra::RealField;

/// A Bezier mesh embedded in [`M`]-dimensional Euclidean space.
/// Generated by a NURBS or B-Spline map of the [`D`]-dimensional parametric [CartMesh].
/// An exemplar mapping can in 2D be schematically visualized as
/// ```text
/// ^ v                           +--+----
/// |    +---+---+---+            |   ⟍    ⟍
/// |    |   |   |   |            |    / +---+
/// |    +---+---+---+       F    +----+   ⟍    ⟍
/// |    |   |   |   |     ====>  |   /  ⟍   ⟍    ⟍
/// |    +---+---+---+            +--+     +--+-----+
/// |    |   |   |   |                 ⟍ ⟋ ⟍   ⟍   |
/// |    +---+---+---+                   |   |   |   |
/// |                 u                  +---+---+---+
/// +------------------>
/// ```
/// where `F` is the geometrical mapping.
#[derive(Debug, Clone)]
pub struct BezierMesh<'a, T: RealField + Copy, const D: usize, const M: usize> {
    /// The cartesian mesh of the parametric domain.
    pub ref_mesh: KnotMesh<T, D>,
    
    // todo:
    //  1. allow for different geo maps. Especially Nurbs maps
    //  2. don't require DeBoorMulti. For that, possibly encode D in BsplineBasis trait
    /// Spline parametrization mapping the reference mesh to the physical Bezier mesh.
    pub geo_map: SplineGeo<'a, T, D, M>
}

impl <'a, T: RealField + Copy, const D: usize, const M: usize> BezierMesh<'a, T, D, M> {
    /// Constructs a new [`BezierMesh`] from the given `ref_mesh` and `geo_map`.
    pub fn new(ref_mesh: KnotMesh<T, D>, geo_map: SplineGeo<'a, T, D, M>) -> Self {
        BezierMesh { ref_mesh, geo_map }
    }
}

impl <'a, T: RealField + Copy, const D: usize, const M: usize> MeshTopology for BezierMesh<'a, T, D, M> {
    type Elem = [KnotSpan; D]; // todo: possibly introduce KnotSpanIdx with multi index
    type ElemIter = KnotSpanIter<D>;

    fn num_elems(&self) -> usize {
        self.ref_mesh.num_elems()
    }
    
    fn elem_iter(&self) -> Self::ElemIter {
        self.ref_mesh.elem_iter()
    }
}