use crate::bspline::spline_geo::SplineGeo;
use crate::cells::bezier_elem::BezierElem;
use crate::mesh::cartesian::{CartMesh, ElemsIter, NodesIter};
use crate::mesh::traits::Mesh;
use nalgebra::RealField;
use crate::cells::cartesian::CartCellIdx;

/// A Bezier mesh embedded in [`M`]-dimensional Euclidean space.
/// Generated by a NURBS or B-Spline map of the [`D`]-dimensional parametric [CartMesh].
/// An exemplar mapping can in 2D be schematically visualized as
/// ```text
/// ^ v                           +--+----
/// |    +---+---+---+            |   ⟍    ⟍
/// |    |   |   |   |            |    / +---+
/// |    +---+---+---+       F    +----+   ⟍    ⟍
/// |    |   |   |   |     ====>  |   /  ⟍   ⟍    ⟍
/// |    +---+---+---+            +--+     +--+-----+
/// |    |   |   |   |                 ⟍ ⟋ ⟍   ⟍   |
/// |    +---+---+---+                   |   |   |   |
/// |                 u                  +---+---+---+
/// +------------------>
/// ```
/// where `F` is the geometrical mapping.
pub struct BezierMesh<'a, T: RealField + Copy, const D: usize, const M: usize> {
    /// The cartesian mesh of the parametric domain.
    pub ref_mesh: CartMesh<T, D>, // todo: change to CartMesh with knot spans
    
    // todo:
    //  1. allow for different geo maps. Especially Nurbs maps
    //  2. don't require DeBoorMulti. For that, possibly encode D in BsplineBasis trait
    /// Spline parametrization mapping the reference mesh to the physical Bezier mesh.
    pub geo_map: SplineGeo<'a, T, [T; D], D, M>
}

impl <'a, T: RealField + Copy, const D: usize, const M: usize> BezierMesh<'a, T, D, M> {
    /// Constructs a new [`BezierMesh`] from the given `ref_mesh` and `geo_map`.
    pub fn new(ref_mesh: CartMesh<T, D>, geo_map: SplineGeo<'a, T, [T; D], D, M>) -> Self {
        BezierMesh { ref_mesh, geo_map }
    }
}

impl <'a, T: RealField + Copy, const D: usize, const M: usize> Mesh<'a, T, [T; D], D, M> for BezierMesh<'a, T, D, M> {
    type Elem = CartCellIdx<D>; // todo: change to knot spans
    type GeoElem = BezierElem<'a, T, D, M>;
    type NodesIter = NodesIter<'a, D>;
    type ElemsIter = ElemsIter<D>;

    fn num_nodes(&self) -> usize {
        self.ref_mesh.num_nodes()
    }

    fn num_elems(&self) -> usize {
        self.ref_mesh.num_elems()
    }

    fn nodes(&'a self) -> Self::NodesIter {
        self.ref_mesh.nodes()
    }

    fn elems(&'a self) -> Self::ElemsIter {
        self.ref_mesh.elems()
    }

    fn geo_elem(&'a self, elem: Self::Elem) -> Self::GeoElem {
        let cell = self.ref_mesh.geo_elem(elem);
        BezierElem::new(cell, &self.geo_map)
    }
}