use crate::bspline::spline_geo::SplineGeo;
use crate::cells::bezier_elem::BezierElem;
use crate::knots::knot_span::KnotSpan;
use crate::mesh::cartesian::NodesIter;
use crate::mesh::knot_mesh::{KnotMesh, KnotSpanIter};
use crate::mesh::traits::{Mesh, MeshTopology};
use nalgebra::RealField;

/// A Bezier mesh embedded in [`M`]-dimensional Euclidean space.
/// Generated by a NURBS or B-Spline map of the [`D`]-dimensional parametric [CartMesh].
/// An exemplar mapping can in 2D be schematically visualized as
/// ```text
/// ^ v                           +--+----
/// |    +---+---+---+            |   ⟍    ⟍
/// |    |   |   |   |            |    / +---+
/// |    +---+---+---+       F    +----+   ⟍    ⟍
/// |    |   |   |   |     ====>  |   /  ⟍   ⟍    ⟍
/// |    +---+---+---+            +--+     +--+-----+
/// |    |   |   |   |                 ⟍ ⟋ ⟍   ⟍   |
/// |    +---+---+---+                   |   |   |   |
/// |                 u                  +---+---+---+
/// +------------------>
/// ```
/// where `F` is the geometrical mapping.
pub struct BezierMesh<'a, T: RealField + Copy, const D: usize, const M: usize> {
    /// The cartesian mesh of the parametric domain.
    pub ref_mesh: KnotMesh<T, D>,
    
    // todo:
    //  1. allow for different geo maps. Especially Nurbs maps
    //  2. don't require DeBoorMulti. For that, possibly encode D in BsplineBasis trait
    /// Spline parametrization mapping the reference mesh to the physical Bezier mesh.
    pub geo_map: SplineGeo<'a, T, [T; D], D, M>
}

impl <'a, T: RealField + Copy, const D: usize, const M: usize> BezierMesh<'a, T, D, M> {
    /// Constructs a new [`BezierMesh`] from the given `ref_mesh` and `geo_map`.
    pub fn new(ref_mesh: KnotMesh<T, D>, geo_map: SplineGeo<'a, T, [T; D], D, M>) -> Self {
        BezierMesh { ref_mesh, geo_map }
    }
}

impl <'a, T: RealField + Copy, const D: usize, const M: usize> MeshTopology<'a, D> for BezierMesh<'a, T, D, M> {
    type Elem = [KnotSpan; D]; // todo: possibly introduce KnotSpanIdx with multi index
    type NodeIter = NodesIter<'a, D>;
    type ElemIter = KnotSpanIter<D>;

    fn num_nodes(&self) -> usize {
        self.ref_mesh.num_nodes()
    }

    fn num_elems(&self) -> usize {
        self.ref_mesh.num_elems()
    }

    fn node_iter(&'a self) -> Self::NodeIter {
        self.ref_mesh.node_iter()
    }

    fn elem_iter(&'a self) -> Self::ElemIter {
        self.ref_mesh.elem_iter()
    }
}

impl <'a, T: RealField + Copy, const D: usize, const M: usize> Mesh<'a, T, [T; D], D, M> for BezierMesh<'a, T, D, M> {
    type GeoElem = BezierElem<'a, T, D, M>;

    fn geo_elem(&'a self, elem: &Self::Elem) -> Self::GeoElem {
        let cell = self.ref_mesh.geo_elem(elem);
        BezierElem::new(cell, &self.geo_map)
    }
}