use crate::space::eval_basis::{EvalBasis, EvalGrad};
use crate::space::local::{FindElem, MeshBasis};
use crate::space::basis::BasisFunctions;
use crate::index::dimensioned::{DimShape, Dimensioned, Strides};
use crate::index::multi_index::MultiIndex;
use itertools::Itertools;
use nalgebra::{Const, Dyn, Matrix, OMatrix, RealField, RowDVector, Scalar, U1};
use std::iter::zip;
use std::marker::PhantomData;

/// A multivariate basis generated by tensor products of (univariate) scalar bases.
/// Given a family `{B[i]}ᵢ` of [`D`] bases with `B[i] = {b₁,...,bₙ}`,
/// the tensor product basis functions are defined as
/// ```text
/// bᵢ: X×...×X ⟶ ℝ   x ↦ bᵢ[1](x[1]) ... bᵢ[d](x[d])
/// ```
#[derive(Debug, Clone, Copy)]
pub struct MultiProd<Basis, const D: usize> {
    /// The bases for each parametric direction.
    pub bases: [Basis; D]
}

impl<Basis, const D: usize> MultiProd<Basis, D> {
    /// Constructs a new [`MultiProd`] from the given array `bases` of `D` univariate bases.
    pub fn new(bases: [Basis; D]) -> Self {
        MultiProd { bases}
    }
}

impl<Basis: Clone, const D: usize> MultiProd<Basis, D> {
    /// Constructs a new [`MultiProd`] using the given `basis` for every parametric direction.
    pub fn repeat(basis: Basis) -> Self {
        Self::new(std::array::from_fn(|_| basis.clone()))
    }
}

// todo: implement shape and strides for GlobalBasis as well, be using super-trait GlobalBasis: Basis

impl<Basis: BasisFunctions, const D: usize> MultiProd<Basis, D> {
    /// Returns the number of basis functions per parametric direction as a [`DimShape`].
    pub fn shape(&self) -> DimShape<D> {
        let arr = self.bases.iter()
            .map(|base| base.num_basis())
            .collect_array();
        DimShape(arr.unwrap())
    }

    /// Returns the [`Strides`] for the basis functions.
    pub fn strides(&self) -> Strides<D> {
        Strides::from(self.shape())
    }
}

/// Computes an evaluated tensor product basis.
///
/// Given an iterator `b` of basis functions for each parametric direction
/// (the coordinate representation of each basis evaluation is given by a [`RowDVector`]),
/// the tensor product basis `b[1] ⊗ ... ⊗ b[D]` is computed.
/// This is done by iteratively calling [`RowDVector::kronecker`] to compute the tensor product
/// of respectively two bases.
fn compute_multi_prod<T: RealField>(b: impl Iterator<Item = RowDVector<T>>) -> RowDVector<T> {
    b.reduce(|acc, bi| acc.kronecker(&bi))
        .expect("Dimension D must be greater than 0!")
}

/// Evaluates the partial derivatives of all basis functions with respect to the `i`-th direction
/// at the parametric point `x` as the column-wise vector `(b[1],...,b[i]/dx[i]...,b[n])`.
fn eval_partial_deriv<T, Basis, const D: usize>(bases: &[Basis; D], x: [T; D], i: usize) -> RowDVector<T>
where T: RealField,
      Basis: EvalGrad<T, NumBasis = Dyn, ParametricDim = U1, Coord<T> = T>,
{
    let b = zip(bases, x)
        .enumerate()
        .map(|(j, (b, xi))| {
            if j == i {
                b.eval_grad(xi) // in 1D this is just the normal derivative
            } else {
                b.eval(xi)
            }
        });

    compute_multi_prod(b)
}

// todo: differentiate between X = T, (T,T), (T,T,T) and [T;D] for efficiency!

impl<Basis: BasisFunctions<NumComponents = U1, ParametricDim = U1, NumBasis = Dyn>, const D: usize> BasisFunctions for MultiProd<Basis, D> {
    type NumBasis = Dyn;
    type NumComponents = U1;
    type ParametricDim = Const<D>;
    type Coord<T> = [T; D];

    fn num_basis_generic(&self) -> Self::NumBasis {
        Dyn(self.shape().len())
    }
}

impl<T, Basis, const D: usize> EvalBasis<T> for MultiProd<Basis, D>
    where T: RealField,
          Basis: EvalBasis<T, NumComponents = U1, NumBasis = Dyn, ParametricDim = U1, Coord<T> = T>
{
    fn eval(&self, x: Self::Coord<T>) -> OMatrix<T, Const<1>, Dyn> {
        let b = zip(&self.bases, x.into_arr()).map(|(b, xi)| b.eval(xi));
        compute_multi_prod(b)
    }
}

impl<T, Basis, const D: usize> EvalGrad<T> for MultiProd<Basis, D>
    where T: RealField + Copy,
          Basis: EvalGrad<T, NumBasis = Dyn, ParametricDim = U1, Coord<T> = T>
{
    fn eval_grad(&self, x: Self::Coord<T>) -> OMatrix<T, Const<D>, Dyn> {
        let partial_derivs = (0..D).map(|i| eval_partial_deriv(&self.bases, x, i)).collect_vec();
        Matrix::from_rows(&partial_derivs)
    }
}

// todo: also implement DiffBasis and HgradBasis

impl<T, Basis, const D: usize> MeshBasis<T> for MultiProd<Basis, D>
    where T: RealField + Copy,
          Basis: MeshBasis<T, NumComponents = U1, NumBasis = Dyn, ParametricDim = U1, Coord<T> = T>,
          Basis::LocalBasis: EvalBasis<T, NumBasis = Dyn> // todo: NumBasis = Dyn is not generic enough!
{
    type Cell = [Basis::Cell; D]; // todo: possibly change to MultiProd<B::Elem>
    type LocalBasis = MultiProd<Basis::LocalBasis, D>;
    type GlobalIndices = impl Iterator<Item = usize> + Clone;
    
    // todo: update this implementation by making HyperRectangle actually a MultiProd<Interval>
    fn local_basis(&self, elem: &Self::Cell) -> Self::LocalBasis {
        let bases = zip(&self.bases, elem)
            .map(|(b, interval)| b.local_basis(interval))
            .collect_array().unwrap();
        MultiProd::new(bases)
    }

    fn global_indices(&self, elem: &Self::Cell) -> Self::GlobalIndices {
        let strides = self.strides();
        zip(&self.bases, elem)
            .map(|(b, b_elem)| b.global_indices(b_elem))
            .multi_cartesian_product()
            .map(|i| TryInto::<[usize; D]>::try_into(i).unwrap())
            .map(move |i| i.into_lin(&strides))
    }
}

impl<T, B, const D: usize> FindElem<T> for MultiProd<B, D>
    where T: RealField + Copy,
          B: FindElem<T, NumComponents = U1, NumBasis = Dyn, ParametricDim = U1, Coord<T> = T>,
          B::LocalBasis: EvalBasis<T, NumBasis = Dyn> // todo: NumBasis = Dyn is not generic enough!
{
    fn find_elem(&self, x: Self::Coord<T>) -> Self::Cell {
        zip(&self.bases, x)
            .map( |(bi, xi)| bi.find_elem(xi))
            .collect_array().unwrap()
    }
}