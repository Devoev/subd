use crate::subd_legacy::basis;
use crate::subd_legacy::face::edges_of_face;
use crate::subd_legacy::mesh::{Face, Node, QuadMesh};
use crate::subd_legacy::patch::Patch;
use iter_num_tools::lin_space;
use itertools::Itertools;
use nalgebra::Point2;
use plotly::common::{ColorScale, ColorScalePalette, Font};
use plotly::layout::{Annotation, Axis, Shape, ShapeType};
use plotly::{Layout, Plot, Scatter, Surface};
use crate::subd_legacy::surface::ParametricMap;

/// Plots the given `faces` of a `msh`.
pub fn plot_faces(msh: &QuadMesh<f64>, faces: impl Iterator<Item=Face>) -> Plot {
    let mut plot = Plot::new();
    let mut layout = Layout::new();

    for (num, face) in faces.enumerate() {
        for edge in edges_of_face(face) {
            let [pi, pj] = msh.nodes_of_edge(&edge);
            let edge = Scatter::new(vec![pi.x, pj.x], vec![pi.y, pj.y]);
            plot.add_trace(edge)
        }
        let center = msh.centroid(face);
        let text = Annotation::new()
            .text(num.to_string())
            .show_arrow(false)
            .x(center.x)
            .y(center.y);
        layout.add_annotation(text);
    }

    plot.set_layout(layout);
    plot
}

/// Plots the given `nodes` of the `msh`.
pub fn plot_nodes(msh: &QuadMesh<f64>, nodes: impl Iterator<Item=Node>) -> Plot {
    let mut plot = Plot::new();
    let mut layout = Layout::new();

    for (num, node) in nodes.enumerate() {
        let pos = msh.node(node);
        let pos_trace = Scatter::new(vec![pos.x], vec![pos.y]);
        plot.add_trace(pos_trace);

        let text = Annotation::new()
            .text(num.to_string())
            .show_arrow(false)
            .x(pos.x)
            .y(pos.y + 0.05);
        layout.add_annotation(text);
    }

    plot.set_layout(layout);
    plot
}

/// Plots the univariate scalar function `b: (0,1) ⟶ ℝ` on the parametric domain.
pub fn plot_fn(b: impl Fn(f64) -> f64, num: usize) -> Plot {
    let mut plot = Plot::new();
    let u_range = lin_space(0.0..=1.0, num);
    let y = u_range.clone().map(b);

    let trace = Scatter::new(u_range.collect(), y.collect());
    plot.add_trace(trace);

    plot
}

/// Plots the bivariate scalar function `b: (0,1)² ⟶ ℝ` on the parametric domain of a patch.
pub fn plot_patch_fn_parametric(b: impl Fn(f64, f64) -> f64, num: usize) -> Plot {
    let mut plot = Plot::new();
    let min = 1e-5;
    let u_range = lin_space(min..=1.0, num);
    let v_range = u_range.clone();

    // Calculate data
    let mut z = vec![vec![0.0; num]; num];
    for (i, u) in u_range.clone().enumerate() {
        for (j, v) in v_range.clone().enumerate() {
            z[i][j] = b(u, v);
        }
    }

    let trace = Surface::new(z).x(u_range.collect()).y(v_range.collect());
    plot.add_trace(trace);

    plot
}

/// Plots the pullback function `f: (0,1)² ⟶ ℝ` over the physical `patch`
/// using `num` evaluation points.
pub fn plot_patch_fn_pullback(patch: &Patch<f64>, f: impl Fn(f64, f64) -> f64, num: usize) -> Plot {
    let mut plot = Plot::new();
    let min = 1e-5;
    let u_range = lin_space(min..=1.0, num);
    let v_range = u_range.clone();

    let mut x = vec![vec![0.0; num]; num];
    let mut y = vec![vec![0.0; num]; num];
    let mut z = vec![vec![0.0; num]; num];

    for (i, u) in u_range.clone().enumerate() {
        for (j, v) in v_range.clone().enumerate() {
            // Evaluate patch
            let pos = patch.parametrization().eval(u, v);

            // Set coordinates
            x[i][j] = pos.x;
            y[i][j] = pos.y;
            z[i][j] = f(u, v);
        }
    }

    let surface = Surface::new(z).x(x).y(y)
        .color_scale(ColorScale::Palette(ColorScalePalette::Viridis))
        .show_scale(false);
    plot.add_trace(surface.clone());
    plot
}

/// Plots the given function `f` over the `patch` by evaluating `num` times in both parametric directions.
pub fn plot_patch_fn(patch: &Patch<f64>, f: impl Fn(Point2<f64>) -> f64, num: usize) -> Plot {
    plot_patch_fn_pullback(patch, |u, v| f(patch.parametrization().eval(u, v)), num)
}

/// Plots the given `patch` using `num` evaluation points.
pub fn plot_patch(patch: &Patch<f64>, num: usize) -> Plot {
    plot_patch_fn(patch, |pos| pos.coords.norm(), num)
}

/// Plots the per-patch pullback functions `f_k: (0,1)² ⟶ ℝ` over the physical surface
/// generated by this `msh` using `num` evaluation points.
pub fn plot_surf_fn_pullback(msh: &QuadMesh<f64>, fk: impl Fn(&Patch<f64>, f64, f64) -> f64 + Clone, num: usize) -> Plot {
    let mut plot = Plot::new();

    for patch in msh.patches() {
        let plot_patch = plot_patch_fn_pullback(&patch, |u, v| fk(&patch, u, v), num);

        plot.add_traces(plot_patch.data().iter().cloned().collect_vec());
    }

    plot
}

/// Plots the given function `f` over the surface generated by the given `msh`
/// using `num` evaluation points.
pub fn plot_surf_fn(msh: &QuadMesh<f64>, f: impl Fn(Point2<f64>) -> f64 + Clone, num: usize) -> Plot {
    plot_surf_fn_pullback(msh, |patch, u, v| f(patch.parametrization().eval(u, v)), num)
}

/// Plots the surface generated by the given `msh`,
/// by evaluating each patch `num` times per parametric direction.
pub fn plot_surf(msh: &QuadMesh<f64>, num: usize) -> Plot {
    plot_surf_fn(msh, |p| p.coords.norm(), num)
}

/// Plots the hierarchy of sub-patches,
/// such that the parametric values `(u,v)` lie in sub-patch `(n,k)`.
pub fn plot_sub_patch_hierarchy(u: f64, v: f64) -> Plot {
    let mut plot = Plot::new();
    plot.add_trace(Scatter::new(vec![u], vec![v]));

    let (ut, vt, num, k) = basis::transform(u, v);

    let mut layout = Layout::new()
        .x_axis(Axis::new().range(vec![0, 1]))
        .y_axis(Axis::new().range(vec![0, 1]));

    layout.add_annotation(Annotation::new()
        .text(format!("Ω^{num}_{k}"))
        .font(Font::new().size(20))
        .show_arrow(true)
        .x(u)
        .y(v)
    );
    
    layout.add_annotation(Annotation::new()
        .text("Mapped point")
        .font(Font::new().size(20))
        .show_arrow(true)
        .x(ut)
        .y(vt)
    );

    for n in 0..=num {
        let z0 = 2f32.powi(-(n as i32) + 1);
        let z1 = 2f32.powi(-(n as i32));
        let vert_line = Shape::new().shape_type(ShapeType::Line)
            .x0(z1).y0(0.0)
            .x1(z1).y1(z0);
        let hor_line = Shape::new().shape_type(ShapeType::Line)
            .x0(0.0).y0(z1)
            .x1(z0).y1(z1);


        layout.add_shape(vert_line);
        layout.add_shape(hor_line);
    }

    plot.set_layout(layout);
    plot
}